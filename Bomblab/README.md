# BombLab

## Phase 1

`objdump -d bomb > assembly.txt` : get a file text of the assembly code of the hole program.
`objdump -t bomb > variables.txt` : get the name of variables in the program
`strings bomb > strings.txt` : get all the printable strings in program

`gdb bomb` : get into gdb
`b phase_1` : put a break point at the beginning of the function `phase_1`
`disas phase_1` :
```
(gdb) disas phase_1
Dump of assembler code for function phase_1:
=> 0x0000000000400f00 <+0>:     sub    $0x8,%rsp
   0x0000000000400f04 <+4>:     mov    $0x4025a0,%esi
   0x0000000000400f09 <+9>:     call   0x40139e <strings_not_equal>
   0x0000000000400f0e <+14>:    test   %eax,%eax
   0x0000000000400f10 <+16>:    je     0x400f17 <phase_1+23>
   0x0000000000400f12 <+18>:    call   0x40160e <explode_bomb>
   0x0000000000400f17 <+23>:    add    $0x8,%rsp
   0x0000000000400f1b <+27>:    ret
End of assembler dump.
```
`p/x $esi` : get the memory address of `$esi` :
```
(gdb) p/x $esi
$1 = 0x6059e0
```
`x /25c 0x6059e0` : print the 25 first characters of the contained in the memory address `0x6059e0` :
```
(gdb) x /25c 0x6059e0
0x6059e0 <input_strings>:       84 'T'  69 'E'  83 'S'  84 'T'  0 '\000'        0 '\000'        0 '\000'        0 '\000'
0x6059e8 <input_strings+8>:     0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'0 '\000'        0 '\000'
0x6059f0 <input_strings+16>:    0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'        0 '\000'0 '\000'        0 '\000'
0x6059f8 <input_strings+24>:    0 '\000'
```
```
(gdb) x /25c 0x4025a0
0x4025a0:       66 'B'  111 'o' 114 'r' 100 'd' 101 'e' 114 'r' 32 ' '  114 'r'
0x4025a8:       101 'e' 108 'l' 97 'a'  116 't' 105 'i' 111 'o' 110 'n' 115 's'
0x4025b0:       32 ' '  119 'w' 105 'i' 116 't' 104 'h' 32 ' '  67 'C'  97 'a'
0x4025b8:       110 'n'
```
```
[]A\A]A^A_
%s: Error: Couldn't open %s
Usage: %s [<input_file>]
That's number 2.  Keep going!
Halfway there!
Good work!  On to the next...
Welcome to my fiendish little bomb. You have 6 phases with
which to blow yourself up. Have a nice day!
Phase 1 defused. How about the next one?
So you got that one.  Try this one.
Border relations with Canada have never been better.
So you think you can stop the bomb with ctrl-c, do you?
Initialization error: Running on an illegal host [1]
Initialization error: Running on an illegal host [2]
```


## Phase 2
```
(gdb) disas phase_2
Dump of assembler code for function phase_2:
=> 0x0000000000400f1c <+0>:     push   %rbp
   0x0000000000400f1d <+1>:     push   %rbx
   0x0000000000400f1e <+2>:     sub    $0x28,%rsp
   0x0000000000400f22 <+6>:     mov    %rsp,%rsi
   0x0000000000400f25 <+9>:     call   0x401644 <read_six_numbers>
   0x0000000000400f2a <+14>:    cmpl   $0x0,(%rsp)
   0x0000000000400f2e <+18>:    jns    0x400f54 <phase_2+56>
   0x0000000000400f30 <+20>:    call   0x40160e <explode_bomb>
   0x0000000000400f35 <+25>:    jmp    0x400f54 <phase_2+56>
   0x0000000000400f37 <+27>:    mov    %ebx,%eax
   0x0000000000400f39 <+29>:    add    -0x4(%rbp),%eax
   0x0000000000400f3c <+32>:    cmp    %eax,0x0(%rbp)
   0x0000000000400f3f <+35>:    je     0x400f46 <phase_2+42>
   0x0000000000400f41 <+37>:    call   0x40160e <explode_bomb>
   0x0000000000400f46 <+42>:    add    $0x1,%ebx
   0x0000000000400f49 <+45>:    add    $0x4,%rbp
   0x0000000000400f4d <+49>:    cmp    $0x6,%ebx
   0x0000000000400f50 <+52>:    jne    0x400f37 <phase_2+27>
   0x0000000000400f52 <+54>:    jmp    0x400f60 <phase_2+68>
   0x0000000000400f54 <+56>:    lea    0x4(%rsp),%rbp
   0x0000000000400f59 <+61>:    mov    $0x1,%ebx
   0x0000000000400f5e <+66>:    jmp    0x400f37 <phase_2+27>
   0x0000000000400f60 <+68>:    add    $0x28,%rsp
   0x0000000000400f64 <+72>:    pop    %rbx
   0x0000000000400f65 <+73>:    pop    %rbp
   0x0000000000400f66 <+74>:    ret
End of assembler dump.
```
```
(gdb) disas read_six_numbers
Dump of assembler code for function read_six_numbers:
   0x0000000000401644 <+0>:     sub    $0x18,%rsp
   0x0000000000401648 <+4>:     mov    %rsi,%rdx
   0x000000000040164b <+7>:     lea    0x4(%rsi),%rcx
   0x000000000040164f <+11>:    lea    0x14(%rsi),%rax
   0x0000000000401653 <+15>:    mov    %rax,0x8(%rsp)
   0x0000000000401658 <+20>:    lea    0x10(%rsi),%rax
   0x000000000040165c <+24>:    mov    %rax,(%rsp)
   0x0000000000401660 <+28>:    lea    0xc(%rsi),%r9
   0x0000000000401664 <+32>:    lea    0x8(%rsi),%r8
   0x0000000000401668 <+36>:    mov    $0x4028a1,%esi
   0x000000000040166d <+41>:    mov    $0x0,%eax
   0x0000000000401672 <+46>:    call   0x400c30 <__isoc99_sscanf@plt>
   0x0000000000401677 <+51>:    cmp    $0x5,%eax
   0x000000000040167a <+54>:    jg     0x401681 <read_six_numbers+61>
   0x000000000040167c <+56>:    call   0x40160e <explode_bomb>
   0x0000000000401681 <+61>:    add    $0x18,%rsp
   0x0000000000401685 <+65>:    ret
End of assembler dump.
```

`r psol.txt` : gdb command to run with the answers

t[0] = 0
t[i] = i + t[i-1]


## Phase 3

```
(gdb) disas phase_3
Dump of assembler code for function phase_3:
   0x0000000000400f67 <+0>:     sub    $0x18,%rsp
   0x0000000000400f6b <+4>:     lea    0x8(%rsp),%rcx
   0x0000000000400f70 <+9>:     lea    0xc(%rsp),%rdx
   0x0000000000400f75 <+14>:    mov    $0x4028ad,%esi
   0x0000000000400f7a <+19>:    mov    $0x0,%eax
   0x0000000000400f7f <+24>:    call   0x400c30 <__isoc99_sscanf@plt>
   0x0000000000400f84 <+29>:    cmp    $0x1,%eax
   0x0000000000400f87 <+32>:    jg     0x400f8e <phase_3+39>
   0x0000000000400f89 <+34>:    call   0x40160e <explode_bomb>
   0x0000000000400f8e <+39>:    cmpl   $0x7,0xc(%rsp)
   0x0000000000400f93 <+44>:    ja     0x400fd1 <phase_3+106>
   0x0000000000400f95 <+46>:    mov    0xc(%rsp),%eax
   0x0000000000400f99 <+50>:    jmp    *0x4025e0(,%rax,8)
   0x0000000000400fa0 <+57>:    mov    $0x34b,%eax
   0x0000000000400fa5 <+62>:    jmp    0x400fe2 <phase_3+123>
   0x0000000000400fa7 <+64>:    mov    $0xb5,%eax
   0x0000000000400fac <+69>:    jmp    0x400fe2 <phase_3+123>
   0x0000000000400fae <+71>:    mov    $0x67,%eax
   0x0000000000400fb3 <+76>:    jmp    0x400fe2 <phase_3+123>
   0x0000000000400fb5 <+78>:    mov    $0x225,%eax
   0x0000000000400fba <+83>:    jmp    0x400fe2 <phase_3+123>
   0x0000000000400fbc <+85>:    mov    $0x2e7,%eax
   0x0000000000400fc1 <+90>:    jmp    0x400fe2 <phase_3+123>
   0x0000000000400fc3 <+92>:    mov    $0x191,%eax
   0x0000000000400fc8 <+97>:    jmp    0x400fe2 <phase_3+123>
   0x0000000000400fca <+99>:    mov    $0x28c,%eax
   0x0000000000400fcf <+104>:   jmp    0x400fe2 <phase_3+123>
   0x0000000000400fd1 <+106>:   call   0x40160e <explode_bomb>
   0x0000000000400fd6 <+111>:   mov    $0x0,%eax
   0x0000000000400fdb <+116>:   jmp    0x400fe2 <phase_3+123>
   0x0000000000400fdd <+118>:   mov    $0xfa,%eax
   0x0000000000400fe2 <+123>:   cmp    0x8(%rsp),%eax
   0x0000000000400fe6 <+127>:   je     0x400fed <phase_3+134>
   0x0000000000400fe8 <+129>:   call   0x40160e <explode_bomb>
   0x0000000000400fed <+134>:   add    $0x18,%rsp
   0x0000000000400ff1 <+138>:   ret
End of assembler dump.
```
Scanf prends 2 entiers %d %d : le 1er `0xc(%rsp)` et le 2nd `0x8(%rsp)` :
```
(gdb) x /s 0x4028ad
0x4028ad:       "%d %d"
```
`jmp    *0x4025e0(,%rax,8)` means jump at the address stored in `8*%rax + 0x4025e0`. The content of `%rax` correspond to our first argument.
```
(gdb) x /8a 0x4025e0
0x4025e0:       0x400fa0 <phase_3+57>   0x400fdd <phase_3+118>
0x4025f0:       0x400fa7 <phase_3+64>   0x400fae <phase_3+71>
0x402600:       0x400fb5 <phase_3+78>   0x400fbc <phase_3+85>
0x402610:       0x400fc3 <phase_3+92>   0x400fca <phase_3+99>
```
Let's take 1 as a first argument and so $0xfa = 255 as second (corresponding to `0x400fdd` which is the 1th element above)

## Phase 4
```
(gdb) disas
Dump of assembler code for function phase_4:
=> 0x0000000000401077 <+0>:     push   %rbx
   0x0000000000401078 <+1>:     sub    $0x10,%rsp
   0x000000000040107c <+5>:     lea    0x8(%rsp),%rcx
   0x0000000000401081 <+10>:    lea    0xc(%rsp),%rdx
   0x0000000000401086 <+15>:    mov    $0x4028ad,%esi
   0x000000000040108b <+20>:    mov    $0x0,%eax
   0x0000000000401090 <+25>:    call   0x400c30 <__isoc99_sscanf@plt>
   0x0000000000401095 <+30>:    cmp    $0x2,%eax
   0x0000000000401098 <+33>:    jne    0x4010a8 <phase_4+49>
   0x000000000040109a <+35>:    mov    0xc(%rsp),%eax
   0x000000000040109e <+39>:    sub    $0x12,%eax
   0x00000000004010a1 <+42>:    cmp    $0x3d5,%eax
   0x00000000004010a6 <+47>:    jbe    0x4010ad <phase_4+54>
   0x00000000004010a8 <+49>:    call   0x40160e <explode_bomb>
   0x00000000004010ad <+54>:    lea    0x4(%rsp),%rsi
   0x00000000004010b2 <+59>:    mov    0xc(%rsp),%edi
   0x00000000004010b6 <+63>:    call   0x400ff2 <func4>
   0x00000000004010bb <+68>:    mov    %eax,%ebx
   0x00000000004010bd <+70>:    mov    0xc(%rsp),%eax
   0x00000000004010c1 <+74>:    lea    -0x1(%rax),%edi
   0x00000000004010c4 <+77>:    mov    $0x0,%esi
   0x00000000004010c9 <+82>:    call   0x400ff2 <func4>
   0x00000000004010ce <+87>:    cmpl   $0x3033,0x4(%rsp)
   0x00000000004010d6 <+95>:    jne    0x4010e2 <phase_4+107>
   0x00000000004010d8 <+97>:    cmp    0x8(%rsp),%ebx
   0x00000000004010dc <+101>:   jne    0x4010e2 <phase_4+107>
   0x00000000004010de <+103>:   cmp    %ebx,%eax
   0x00000000004010e0 <+105>:   jne    0x4010e7 <phase_4+112>
   0x00000000004010e2 <+107>:   call   0x40160e <explode_bomb>
   0x00000000004010e7 <+112>:   add    $0x10,%rsp
   0x00000000004010eb <+116>:   pop    %rbx
   0x00000000004010ec <+117>:   ret
End of assembler dump.
```
Like phase 4, 2 integers : le 1er `0xc(%rsp)` et le 2nd `0x8(%rsp)`

